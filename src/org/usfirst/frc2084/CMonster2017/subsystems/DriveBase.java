// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2084.CMonster2017.subsystems;

import org.usfirst.frc2084.CMonster2017.Robot;
import org.usfirst.frc2084.CMonster2017.RobotMap;
import org.usfirst.frc2084.CMonster2017.Drive.ArcadeDrive;
import org.usfirst.frc2084.CMonster2017.Drive.JoystickSensitivity;
import org.usfirst.frc2084.CMonster2017.PID.DistancePID;
import org.usfirst.frc2084.CMonster2017.PID.HeadingPID;
import org.usfirst.frc2084.CMonster2017.commands.*;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.GenericHID.Hand;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import com.ctre.*;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.smartdashboard.*;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 *
 */
public class DriveBase extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final AHRS ahrs = RobotMap.ahrs; //the navX

	// There are 2 driver motors on each side of the robot.
	// Here are the declarations.
	private final CANTalon leftTalon1 = RobotMap.driveBaseLeftTalon1;
	// private final PIDController leftPIDController2 =
	// RobotMap.driveBasePIDLeftPIDController2;
	private final CANTalon rightTalon1 = RobotMap.driveBaseRightTalon1; //only need the 2 main talons,
	// private final PIDController rightPIDController2 =				//not the followers
	// RobotMap.driveBasePIDRightPIDController2;

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	double leftMotorSpeed; // variables used to calculate motor speed
	double rightMotorSpeed;
	double moveSpeed; //take the values from the PIDs
	double rotateSpeed;

	boolean InPosition; // variables for autonomous
	public static double LeftDistance; //left and right distance are averaged for the average distance
	public static double RightDistance;
	public static double scale = 1.0; //scale starts at normal, changes to 0.25 when button is pressed
	int Waypoint = 1; // the number of way points stating at 1.
	double[] WayPoints = new double[3]; // array with 3 elements holding the
										// distance to each way point;
	ArcadeDrive arcadeDrive = new ArcadeDrive();
	JoystickSensitivity joystickSensitivity = new JoystickSensitivity();
	private final double WheelDiameter = RobotMap.DRIVE_SUBSYSTEM_WHEEL_DIAMETER;
	double[] returnData = new double[2];
	Joystick RightJoystick; //two joysticks
	Joystick LeftJoystick;
	public boolean isInverted = false;  //inversion starts as false

	HeadingPID headingPID = RobotMap.headingPID; // instance variables
	DistancePID distancePID = RobotMap.distancePID;

	public void EnableDriveBase() {
		leftTalon1.reset(); // reset PID controllers before enable to prevent
							// "wind up"
		rightTalon1.reset();
		leftTalon1.enable();
		rightTalon1.enable();
		distancePID.enable();

		headingPID.enable();
		Robot.gearBase.CompressorOn(); //turn on the compressor when the robot is enabled
		leftTalon1.setPosition(0);
		rightTalon1.setPosition(0);
		
	}

	public void DisableDriveBase() {
		leftTalon1.disable();
		rightTalon1.disable();
		distancePID.disable();
		headingPID.disable();
	}

	public void DriveAutonomous() {

		moveSpeed = distancePID.getOutput(); //PID values are stored in moveSpeed and rotatSpeed
		rotateSpeed = headingPID.getOutput(); // Get and store the output from
												// the heading PID controller.

		SmartDashboard.putNumber("HeadingPID", rotateSpeed);// rotateSpeed is
															// the value of
															// HeadingPID
		SmartDashboard.putNumber("YAW", (double) ahrs.getYaw());
		SmartDashboard.putNumber("DistancePID", moveSpeed);
		// SmartDashboard.putNumber("pitch", (double)ahrs.getPitch());
		// SmartDashboard.putNumber("roll", (double)ahrs.getRoll());

		returnData = arcadeDrive.calculateSpeed(moveSpeed, rotateSpeed);
		//uses output from PIDs to calculate distance traveled in the archade drive command
		//takes readings from PIDs to calculate speed: see archade drive class
		leftMotorSpeed = returnData[0]; //assign returnData speed to left and right motor speed
		rightMotorSpeed = returnData[1]; //data back from archade drive calculations
		// these 3 lines replace the arcade calculations blocks, call them from ArchadeDrive class

		leftTalon1.set(leftMotorSpeed * 586); // set thing to max RPM
		rightTalon1.set(rightMotorSpeed * 586); //left and right motor speed are calculated by
												//archade drive class.
		//multiply speed (-1 to +1) by max RPM to get the requested setting to the talons,
		//which in turn tell the motors how fast to go using the f-term.

		// LeftDistance = leftEncoder.getDistance(); //Read encoder distance
		// traveled in meters.
		// RightDistance = rightEncoder.getDistance();
		// have to invert rightDistance so the average isn't negative
		
		
		//getPosition gets value from the encoders
		LeftDistance = leftTalon1.getPosition() * RobotMap.DISTANCE_PER_PULSE;
		RightDistance = rightTalon1.getPosition() * RobotMap.DISTANCE_PER_PULSE;
		//distance per pulse is really the circumference of wheel: should be "distance per revolution"
		//multiply the number of pulses of talon (can deduce how many revolutions by dividing by 2048)
		//by the distance traveled per rotation to get total distance
		
		//(pulses tell how many revolutions (pulses divided by 2084 yields number of revolutions))
		
		//encoders measure pulses, which is multiplied by distance per revolution, to get total 
		//distance for each side. Left and Right Distance are averaged to get AverageDistance
		
		LeftDistance *= -1;  //invert the leftDistance so values are positive
		RobotMap.AverageDistance = (LeftDistance + RightDistance) / 2; // Calculate
																		// the
																		// average
																		// distance
																		// traveled.

		//SmartDashboard stuff		
		//SmartDashboard.putNumber("WheelDiameter", WheelDiameter);
		SmartDashboard.putNumber("LeftDistance", LeftDistance);
		SmartDashboard.putNumber("AV Distance", RobotMap.AverageDistance);
		SmartDashboard.putNumber("Right Distance", RightDistance);
		SmartDashboard.putBoolean("Inversion", isInverted);
		SmartDashboard.putNumber("RightTalonPosition", rightTalon1.getPosition());
		SmartDashboard.putNumber("LeftTalonPosition", leftTalon1.getPosition());
		SmartDashboard.putNumber("DistancePerPulse", RobotMap.DISTANCE_PER_PULSE);
		// SmartDashboard.putNumber("HeadingPID", headingPID.getOutput());
		SmartDashboard.putNumber("LeftMotorSpeed", leftMotorSpeed);
		SmartDashboard.putNumber("RightMotorSpeed", rightMotorSpeed);
					

	}

	// method called during teleop from DriveWithJoystick command. executes
	// arcade drive algorithm using joy stick inputs.
	public void JoystickInputs(Joystick RightJoystick, Joystick LeftJoystick) { // teleop// method

	
		
		// moveSpeed = stick.getY() * -1; // set variables = Joystick inputs
		// invert the y value to -1 so that pushing the joystick forward gives a
		// positive value

		// rotateSpeed = stick.getX() * -1; //also invert the x value so
		// right/left aren't inverted

		// returnData = arcadeDrive.calculateSpeed(moveSpeed, rotateSpeed);

		//these are the commands for inverting the drive, called into the Inversion command
		//if (isInverted) {
		
		/*
			rightTalon1.setInverted(isInverted);  //isInverted can be either true/false 
			leftTalon1.setInverted(isInverted);		//-set in button command "Inversion"
			if (!isInverted){
				leftMotorSpeed = LeftJoystick.getY();  //get value of leftMotorSpeed directly from joystick
				rightMotorSpeed = RightJoystick.getY() * -1;
			} else {
				leftMotorSpeed = RightJoystick.getY();
				rightMotorSpeed = LeftJoystick.getY() * -1;
			}
			
			*/
			
//		}
/*
		 else {
			rightTalon1.setInverted(false);
			leftTalon1.setInverted(false);
			leftMotorSpeed = LeftJoystick.getY() * -1;
			rightMotorSpeed = RightJoystick.getY();
		}
		*/
		
		
		SmartDashboard.putNumber("RightTalonPosition", rightTalon1.getPosition());
		SmartDashboard.putNumber("LeftTalonPosition", leftTalon1.getPosition());
		SmartDashboard.putNumber("YAW", (double) ahrs.getYaw());


		//these were getting the values from the joystick before the joystick sensitivity stuff
		//leftMotorSpeed = LeftJoystick.getY() * -1;
		//rightMotorSpeed = RightJoystick.getY();
		//commented out way before
	
		
		//leftMotorSpeed = Logitech.getRawAxis(3);
		//rightMotorSpeed = Logitech.getY() * -1;
		//FOR PARADE
	
		
		//joystick sensitivity stuff replaces the getY stuff

		leftMotorSpeed = joystickSensitivity.GetOutput(leftMotorSpeed);
		rightMotorSpeed = joystickSensitivity.GetOutput(rightMotorSpeed);
		
		//joystick sensitivity stuff: set the speed of the motor to the output once its been cubed

		// Drive the left and right sides of the robot at the specified speeds.
		rightTalon1.set(rightMotorSpeed * 586 * scale); //set to max RPM
		leftTalon1.set(leftMotorSpeed * 586 * scale); //multiply by scale so changing the variable
														//can affect the max speed
		
		//leftMotor speed and rightMotorSpeed are doubles (-1 to +1)
		//tell how much of max speed to set, give to the talons to set

	}

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}
}
